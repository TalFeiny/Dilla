'use client';

import * as tf from '@tensorflow/tfjs/dist/index';
import { SimpleEmbeddings as LocalEmbeddings } from './simple-embeddings';
import { Experience } from './experience-collector';

export interface PolicyAction {
  action: string;
  confidence: number;
  reasoning: string;
  source: 'learned' | 'exploration' | 'retrieval';
}

export class RAGPolicyAgent {
  private embeddings: LocalEmbeddings;
  private model: tf.LayersModel | null = null;
  private epsilon: number = 0.1; // Exploration rate
  private temperature: number = 1.0; // For action sampling
  private isTraining: boolean = false; // Prevent concurrent training
  
  constructor() {
    this.embeddings = LocalEmbeddings.getInstance();
    this.initializeModel();
  }
  
  private initializeModel() {
    // Simple policy network
    this.model = tf.sequential({
      layers: [
        tf.layers.dense({ 
          inputShape: [384], 
          units: 256, 
          activation: 'relu',
          kernelInitializer: 'glorotUniform'
        }),
        tf.layers.dropout({ rate: 0.2 }),
        tf.layers.dense({ 
          units: 128, 
          activation: 'relu' 
        }),
        tf.layers.dropout({ rate: 0.1 }),
        tf.layers.dense({ 
          units: 64, 
          activation: 'relu' 
        }),
        // Output layer: action type probabilities
        tf.layers.dense({ 
          units: 32, 
          activation: 'softmax' 
        })
      ]
    });
    
    // Compile with Adam optimizer
    this.model.compile({
      optimizer: tf.train.adam(0.001),
      loss: 'categoricalCrossentropy',
      metrics: ['accuracy']
    });
  }
  
  async selectAction(
    currentGrid: Record<string, any>,
    userIntent: string,
    modelType?: string
  ): Promise<PolicyAction> {
    await this.embeddings.initialize();
    
    // Ensure model is properly initialized before use
    if (!this.model) {
      this.initializeModel();
    }
    
    // Embed current state
    const stateEmbedding = await this.embeddings.embedGrid(currentGrid);
    
    // Epsilon-greedy exploration
    if (Math.random() < this.epsilon) {
      return this.exploreNewAction(currentGrid, userIntent);
    }
    
    // Try retrieval first (most reliable)
    const retrievedAction = await this.retrieveSimilarAction(
      stateEmbedding,
      modelType
    );
    
    if (retrievedAction) {
      return retrievedAction;
    }
    
    // Fall back to learned policy
    return this.generateLearnedAction(stateEmbedding, currentGrid, userIntent);
  }
  
  private async retrieveSimilarAction(
    stateEmbedding: number[],
    modelType?: string
  ): Promise<PolicyAction | null> {
    try {
      // Query database for similar successful experiences
      const response = await fetch('/api/agent/rl-experience/match', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          embedding: stateEmbedding,
          modelType,
          minReward: 0.5,
          limit: 5
        })
      });
      
      if (!response.ok) return null;
      
      const { experiences } = await response.json();
      
      if (!experiences || experiences.length === 0) return null;
      
      // Use the best matching successful action
      const bestExp = experiences[0];
      
      return {
        action: bestExp.action_text,
        confidence: bestExp.similarity * bestExp.reward,
        reasoning: `Retrieved from similar successful experience (similarity: ${(bestExp.similarity * 100).toFixed(1)}%, reward: ${bestExp.reward.toFixed(2)})`,
        source: 'retrieval'
      };
    } catch (error) {
      console.error('Failed to retrieve similar actions:', error);
      return null;
    }
  }
  
  private async generateLearnedAction(
    stateEmbedding: number[],
    currentGrid: Record<string, any>,
    userIntent: string
  ): Promise<PolicyAction> {
    if (!this.model) {
      return this.exploreNewAction(currentGrid, userIntent);
    }
    
    try {
      // Get action probabilities from neural network
      const input = tf.tensor2d([stateEmbedding]);
      const output = this.model.predict(input) as tf.Tensor;
      const probs = await output.data();
      
      // Sample action based on probabilities and temperature
      const actionIndex = this.sampleAction(Array.from(probs));
      const action = this.decodeAction(actionIndex, currentGrid, userIntent);
      
      // Cleanup tensors
      input.dispose();
      output.dispose();
      
      return {
        action,
        confidence: probs[actionIndex],
        reasoning: `Generated by learned policy (confidence: ${(probs[actionIndex] * 100).toFixed(1)}%)`,
        source: 'learned'
      };
    } catch (error) {
      console.error('Failed to generate learned action:', error);
      // Fall back to exploration if model prediction fails
      return this.exploreNewAction(currentGrid, userIntent);
    }
  }
  
  private exploreNewAction(
    currentGrid: Record<string, any>,
    userIntent: string
  ): PolicyAction {
    // Detect model type from intent
    const modelType = this.detectModelType(userIntent);
    const actions = this.getModelSpecificActions(modelType, currentGrid);
    
    // Choose action based on current grid state
    const action = this.selectSmartAction(actions, currentGrid, userIntent);
    
    return {
      action: action,
      confidence: 0.5,
      reasoning: `Exploration action for ${modelType} model`,
      source: 'exploration'
    };
  }
  
  private detectModelType(intent: string): string {
    const lower = intent.toLowerCase();
    if (lower.includes('cap table') || lower.includes('captable') || lower.includes('ownership')) return 'CapTable';
    if (lower.includes('waterfall') || lower.includes('liquidation') || lower.includes('exit')) return 'Waterfall';
    if (lower.includes('dcf') || lower.includes('discounted cash')) return 'DCF';
    if (lower.includes('ic') || lower.includes('investment committee')) return 'IC';
    if (lower.includes('cim') || lower.includes('confidential information')) return 'CIM';
    if (lower.includes('comparison') || lower.includes('comparable') || lower.includes('comp')) return 'Comparison';
    if (lower.includes('revenue') || lower.includes('sales')) return 'Revenue';
    if (lower.includes('saas') || lower.includes('mrr') || lower.includes('arr')) return 'SaaS';
    if (lower.includes('valuation') || lower.includes('multiple')) return 'Valuation';
    if (lower.includes('p&l') || lower.includes('profit')) return 'P&L';
    if (lower.includes('cohort')) return 'Cohort';
    if (lower.includes('unit economics')) return 'UnitEconomics';
    if (lower.includes('burn') || lower.includes('runway')) return 'BurnAnalysis';
    return 'Financial';
  }
  
  private getModelSpecificActions(modelType: string, grid: Record<string, any>): string[] {
    const hasData = Object.keys(grid).some(key => grid[key]?.value);
    
    switch (modelType) {
      case 'DCF':
        return hasData ? [
          'grid.write("A1", "DCF Model")',
          'grid.write("A3", "Revenue")',
          'grid.write("A4", "COGS")',
          'grid.write("A5", "Gross Profit")',
          'grid.formula("B5", "=B3-B4")',
          'grid.write("A6", "Operating Expenses")',
          'grid.write("A7", "EBITDA")',
          'grid.formula("B7", "=B5-B6")',
          'grid.write("A9", "Terminal Value")',
          'grid.write("A10", "Discount Rate")',
          'grid.write("B10", "0.12")',
          'grid.formula("B9", "=B7*10/(B10)")',
          'grid.format("B3:B9", "currency")',
          'grid.format("B10", "percent")'
        ] : [
          'grid.write("A1", "DCF Valuation Model")',
          'grid.style("A1", {bold: true, fontSize: 16})',
          'grid.write("A3", "Year")',
          'grid.writeRange("B3", "F3", [["2024", "2025", "2026", "2027", "2028"]])',
          'grid.write("A4", "Revenue")',
          'grid.write("B4", "1000000")',
          'grid.formula("C4", "=B4*1.3")',
          'grid.formula("D4", "=C4*1.25")',
          'grid.formula("E4", "=D4*1.2")',
          'grid.formula("F4", "=E4*1.15")'
        ];
        
      case 'Revenue':
        return hasData ? [
          'grid.write("A8", "Growth Rate")',
          'grid.formula("B8", "=(B4/B3)-1")',
          'grid.format("B8", "percent")',
          'grid.write("A9", "CAGR")',
          'grid.formula("B9", "=((F4/B4)^(1/4))-1")',
          'grid.format("B9", "percent")'
        ] : [
          'grid.write("A1", "Revenue Forecast")',
          'grid.style("A1", {bold: true, fontSize: 16})',
          'grid.write("A3", "Month")',
          'grid.write("A4", "New Customers")',
          'grid.write("A5", "ARPU")',
          'grid.write("A6", "Revenue")',
          'grid.formula("B6", "=B4*B5")',
          'grid.write("B4", "100")',
          'grid.write("B5", "500")',
          'grid.format("B5:B6", "currency")'
        ];
        
      case 'SaaS':
        return hasData ? [
          'grid.write("A10", "Churn Rate")',
          'grid.write("B10", "0.05")',
          'grid.format("B10", "percent")',
          'grid.write("A11", "LTV")',
          'grid.formula("B11", "=B5/B10")',
          'grid.format("B11", "currency")',
          'grid.write("A12", "CAC")',
          'grid.write("B12", "1500")',
          'grid.format("B12", "currency")',
          'grid.write("A13", "LTV/CAC")',
          'grid.formula("B13", "=B11/B12")',
          'grid.format("B13", "number")'
        ] : [
          'grid.write("A1", "SaaS Metrics")',
          'grid.style("A1", {bold: true, fontSize: 16})',
          'grid.write("A3", "MRR")',
          'grid.write("B3", "50000")',
          'grid.write("A4", "ARR")',
          'grid.formula("B4", "=B3*12")',
          'grid.write("A5", "Customers")',
          'grid.write("B5", "100")',
          'grid.write("A6", "ARPU")',
          'grid.formula("B6", "=B3/B5")',
          'grid.format("B3:B4", "currency")',
          'grid.format("B6", "currency")'
        ];
        
      case 'P&L':
        return hasData ? [
          'grid.write("A8", "Gross Margin")',
          'grid.formula("B8", "=B5/B3")',
          'grid.format("B8", "percent")',
          'grid.write("A9", "EBITDA Margin")',
          'grid.formula("B9", "=B7/B3")',
          'grid.format("B9", "percent")'
        ] : [
          'grid.write("A1", "P&L Statement")',
          'grid.style("A1", {bold: true, fontSize: 16})',
          'grid.write("A3", "Revenue")',
          'grid.write("A4", "COGS")',
          'grid.write("A5", "Gross Profit")',
          'grid.formula("B5", "=B3-B4")',
          'grid.write("A6", "OpEx")',
          'grid.write("A7", "EBITDA")',
          'grid.formula("B7", "=B5-B6")',
          'grid.write("A8", "D&A")',
          'grid.write("A9", "EBIT")',
          'grid.formula("B9", "=B7-B8")',
          'grid.write("A10", "Interest")',
          'grid.write("A11", "Tax")',
          'grid.write("A12", "Net Income")',
          'grid.formula("B12", "=B9-B10-B11")'
        ];
        
      case 'Valuation':
        return [
          'grid.write("A1", "Valuation Analysis")',
          'grid.style("A1", {bold: true, fontSize: 16})',
          'grid.write("A3", "Revenue Multiple")',
          'grid.write("B3", "5")',
          'grid.write("A4", "Revenue")',
          'grid.write("B4", "10000000")',
          'grid.write("A5", "Valuation (Revenue)")',
          'grid.formula("B5", "=B3*B4")',
          'grid.write("A7", "EBITDA Multiple")',
          'grid.write("B7", "15")',
          'grid.write("A8", "EBITDA")',
          'grid.write("B8", "2000000")',
          'grid.write("A9", "Valuation (EBITDA)")',
          'grid.formula("B9", "=B7*B8")',
          'grid.format("B4:B9", "currency")'
        ];
        
      case 'UnitEconomics':
        return [
          'grid.write("A1", "Unit Economics")',
          'grid.style("A1", {bold: true, fontSize: 16})',
          'grid.write("A3", "Revenue per Unit")',
          'grid.write("B3", "100")',
          'grid.write("A4", "Variable Cost per Unit")',
          'grid.write("B4", "40")',
          'grid.write("A5", "Contribution Margin")',
          'grid.formula("B5", "=B3-B4")',
          'grid.write("A6", "Contribution Margin %")',
          'grid.formula("B6", "=B5/B3")',
          'grid.write("A8", "Fixed Costs")',
          'grid.write("B8", "50000")',
          'grid.write("A9", "Breakeven Units")',
          'grid.formula("B9", "=B8/B5")',
          'grid.format("B3:B5", "currency")',
          'grid.format("B6", "percent")',
          'grid.format("B8", "currency")'
        ];
        
      case 'Cohort':
        return [
          'grid.write("A1", "Cohort Analysis")',
          'grid.style("A1", {bold: true, fontSize: 16})',
          'grid.write("A3", "Cohort")',
          'grid.write("B3", "Month 0")',
          'grid.write("C3", "Month 1")',
          'grid.write("D3", "Month 2")',
          'grid.write("E3", "Month 3")',
          'grid.write("A4", "Jan 2024")',
          'grid.write("B4", "1000")',
          'grid.write("C4", "950")',
          'grid.write("D4", "903")',
          'grid.write("E4", "858")',
          'grid.write("A5", "Retention %")',
          'grid.formula("C5", "=C4/B4")',
          'grid.formula("D5", "=D4/B4")',
          'grid.formula("E5", "=E4/B4")',
          'grid.format("C5:E5", "percent")'
        ];
        
      case 'BurnAnalysis':
        return [
          'grid.write("A1", "Burn Rate & Runway")',
          'grid.style("A1", {bold: true, fontSize: 16})',
          'grid.write("A3", "Cash Balance")',
          'grid.write("B3", "5000000")',
          'grid.write("A4", "Monthly Revenue")',
          'grid.write("B4", "200000")',
          'grid.write("A5", "Monthly Expenses")',
          'grid.write("B5", "450000")',
          'grid.write("A6", "Net Burn")',
          'grid.formula("B6", "=B5-B4")',
          'grid.write("A7", "Runway (months)")',
          'grid.formula("B7", "=B3/B6")',
          'grid.format("B3:B6", "currency")',
          'grid.style("B6", {color: "red"})',
          'grid.style("B7", {bold: true})'
        ];
        
      default:
        return [
          'grid.write("A1", "Financial Model")',
          'grid.write("A3", "Metric")',
          'grid.write("B3", "Value")',
          'grid.write("A4", "Revenue")',
          'grid.write("A5", "Costs")',
          'grid.write("A6", "Profit")',
          'grid.formula("B6", "=B4-B5")',
          'grid.format("B4:B6", "currency")'
        ];
    }
  }
  
  private selectSmartAction(actions: string[], grid: Record<string, any>, intent: string): string {
    // If grid is empty, start with the first action (usually title)
    if (Object.keys(grid).filter(k => grid[k]?.value).length === 0) {
      return actions[0];
    }
    
    // Check what's already in the grid and pick next logical action
    const gridContent = JSON.stringify(grid).toLowerCase();
    
    // Pick actions that haven't been done yet
    for (const action of actions) {
      const actionContent = action.toLowerCase();
      
      // Extract what this action would write
      const writeMatch = action.match(/write\("[^"]+",\s*"([^"]+)"/);
      if (writeMatch) {
        const content = writeMatch[1].toLowerCase();
        // If this content isn't in the grid yet, do this action
        if (!gridContent.includes(content)) {
          return action;
        }
      }
      
      // For formulas, check if the cell is empty
      const formulaMatch = action.match(/formula\("([^"]+)"/);
      if (formulaMatch) {
        const cell = formulaMatch[1];
        if (!grid[cell]?.value) {
          return action;
        }
      }
    }
    
    // Default to a random action from the list
    return actions[Math.floor(Math.random() * actions.length)];
  }
  
  private findNextEmptyCell(grid: Record<string, any>): string {
    // Find the next logical empty cell
    const filledCells = Object.keys(grid).filter(key => grid[key]?.value);
    if (filledCells.length === 0) return 'A1';
    
    // Get max row and column
    let maxRow = 0;
    let maxCol = 0;
    
    filledCells.forEach(cell => {
      const match = cell.match(/^([A-Z]+)(\d+)$/);
      if (match) {
        const col = match[1].charCodeAt(0) - 65;
        const row = parseInt(match[2]);
        maxCol = Math.max(maxCol, col);
        maxRow = Math.max(maxRow, row);
      }
    });
    
    // Return next cell in pattern
    if (maxCol < 25) {
      return String.fromCharCode(65 + maxCol + 1) + maxRow;
    } else {
      return 'A' + (maxRow + 1);
    }
  }
  
  private sampleAction(probabilities: number[]): number {
    // Apply temperature to probabilities
    const adjustedProbs = probabilities.map(p => 
      Math.pow(p, 1 / this.temperature)
    );
    
    // Normalize
    const sum = adjustedProbs.reduce((a, b) => a + b, 0);
    const normalizedProbs = adjustedProbs.map(p => p / sum);
    
    // Sample from distribution
    const random = Math.random();
    let cumSum = 0;
    
    for (let i = 0; i < normalizedProbs.length; i++) {
      cumSum += normalizedProbs[i];
      if (random <= cumSum) return i;
    }
    
    return normalizedProbs.length - 1;
  }
  
  private decodeAction(index: number, grid: Record<string, any>, intent: string): string {
    // Map index to action type
    const actionTypes = [
      'write', 'formula', 'format', 'style', 'clear', 'link', 'writeRange'
    ];
    
    const actionType = actionTypes[index % actionTypes.length];
    const cell = this.findNextEmptyCell(grid);
    
    // Generate action based on type and intent
    switch (actionType) {
      case 'write':
        return `grid.write("${cell}", "Value")`;
      case 'formula':
        return `grid.formula("${cell}", "=A1+B1")`;
      case 'format':
        return `grid.format("${cell}", "currency")`;
      case 'style':
        return `grid.style("${cell}", {bold: true})`;
      case 'clear':
        return `grid.clear("${cell}")`;
      case 'link':
        return `grid.link("${cell}", "Link", "https://example.com")`;
      case 'writeRange':
        return `grid.writeRange("${cell}", "C5", [[1,2],[3,4]])`;
      default:
        return `grid.write("${cell}", "")`;
    }
  }
  
  async updatePolicy(experiences: Experience[]) {
    if (experiences.length === 0) return;
    
    // Prevent concurrent training
    if (this.isTraining) {
      console.warn('Training already in progress, skipping...');
      return;
    }
    
    this.isTraining = true;
    
    try {
      // Ensure model is initialized
      if (!this.model) {
        this.initializeModel();
      }
      
      // Prepare training data
    const states: number[][] = [];
    const targets: number[][] = [];
    
    for (const exp of experiences) {
      states.push(exp.stateEmbedding);
      
      // Create target: reward-weighted action type
      const actionType = this.getActionTypeIndex(exp.metadata.actionText);
      const target = new Array(32).fill(0);
      target[actionType] = exp.reward > 0 ? exp.reward : 0;
      targets.push(target);
    }
    
    // Convert to tensors
    const xTrain = tf.tensor2d(states);
    const yTrain = tf.tensor2d(targets);
    
      // Train model
      await this.model.fit(xTrain, yTrain, {
        epochs: 10,
        batchSize: Math.min(32, experiences.length),
        shuffle: true,
        verbose: 0
      });
      
      // Cleanup
      xTrain.dispose();
      yTrain.dispose();
    } catch (error) {
      console.error('Training error:', error);
    } finally {
      this.isTraining = false;
    }
  }
  
  private getActionTypeIndex(action: string): number {
    if (action.includes('write')) return 0;
    if (action.includes('formula')) return 1;
    if (action.includes('format')) return 2;
    if (action.includes('style')) return 3;
    if (action.includes('clear')) return 4;
    if (action.includes('link')) return 5;
    if (action.includes('writeRange')) return 6;
    return 0;
  }
  
  // Adjust exploration rate
  setEpsilon(epsilon: number) {
    this.epsilon = Math.max(0, Math.min(1, epsilon));
  }
  
  // Adjust temperature for action sampling
  setTemperature(temperature: number) {
    this.temperature = Math.max(0.1, temperature);
  }
  
  // Save model to localStorage
  async saveModel() {
    if (!this.model) return;
    await this.model.save('localstorage://spreadsheet-policy');
  }
  
  // Load model from localStorage
  async loadModel() {
    try {
      const loadedModel = await tf.loadLayersModel('localstorage://spreadsheet-policy');
      
      // Recompile the loaded model (required after loading)
      loadedModel.compile({
        optimizer: tf.train.adam(0.001),
        loss: 'categoricalCrossentropy',
        metrics: ['accuracy']
      });
      
      this.model = loadedModel;
      console.log('Loaded and compiled saved policy model');
    } catch (error) {
      console.log('No saved model found, initializing fresh model');
      // Initialize a new model if loading fails
      this.initializeModel();
    }
  }
  
  // Get learning stats
  getStats() {
    return {
      epsilon: this.epsilon,
      temperature: this.temperature,
      modelLoaded: this.model !== null
    };
  }
}