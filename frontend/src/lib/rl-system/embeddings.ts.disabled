'use client';

import { pipeline, Pipeline } from '@xenova/transformers';

// Singleton class for local embeddings using Transformers.js
export class LocalEmbeddings {
  private static instance: LocalEmbeddings;
  private embedder: Pipeline | null = null;
  private initPromise: Promise<void> | null = null;
  
  private constructor() {}
  
  static getInstance(): LocalEmbeddings {
    if (!LocalEmbeddings.instance) {
      LocalEmbeddings.instance = new LocalEmbeddings();
    }
    return LocalEmbeddings.instance;
  }
  
  async initialize() {
    if (this.embedder) return;
    if (this.initPromise) return this.initPromise;
    
    this.initPromise = this.loadModel();
    await this.initPromise;
  }
  
  private async loadModel() {
    try {
      console.log('Loading local embedding model...');
      // Use a small, fast model that works well in browser
      this.embedder = await pipeline(
        'feature-extraction',
        'Xenova/all-MiniLM-L6-v2',
        { 
          quantized: true,  // Use quantized model for faster loading
          progress_callback: (progress: any) => {
            if (progress.status === 'progress') {
              console.log(`Loading embeddings model: ${Math.round(progress.progress)}%`);
            }
          }
        }
      );
      console.log('Embedding model loaded successfully');
    } catch (error) {
      console.error('Failed to load embedding model:', error);
      throw error;
    }
  }
  
  async embed(text: string): Promise<number[]> {
    await this.initialize();
    if (!this.embedder) throw new Error('Embedder not initialized');
    
    // Truncate text if too long (model has max token limit)
    const truncatedText = text.slice(0, 512);
    
    const output = await this.embedder(truncatedText, {
      pooling: 'mean',
      normalize: true
    });
    
    // Convert to regular array and ensure it's 384 dimensions
    return Array.from(output.data as Float32Array);
  }
  
  // Convert grid state to text representation for embedding
  gridToText(grid: Record<string, any>): string {
    const entries = Object.entries(grid)
      .filter(([_, cell]) => cell?.value !== undefined && cell?.value !== '')
      .map(([addr, cell]) => {
        const value = cell.formula || cell.value;
        const type = cell.type || 'text';
        return `${addr}:${value}[${type}]`;
      })
      .slice(0, 50); // Limit to first 50 cells to avoid token limit
    
    return entries.join(' ');
  }
  
  // Embed a grid state
  async embedGrid(grid: Record<string, any>): Promise<number[]> {
    const gridText = this.gridToText(grid);
    return this.embed(gridText);
  }
  
  // Embed an action
  async embedAction(action: string): Promise<number[]> {
    // Normalize action text for better embeddings
    const normalizedAction = action
      .replace(/grid\./g, '')
      .replace(/['"]/g, '')
      .replace(/\s+/g, ' ')
      .trim();
    
    return this.embed(`spreadsheet action: ${normalizedAction}`);
  }
  
  // Calculate similarity between two embeddings
  cosineSimilarity(a: number[], b: number[]): number {
    if (a.length !== b.length) throw new Error('Embeddings must have same dimension');
    
    let dotProduct = 0;
    let normA = 0;
    let normB = 0;
    
    for (let i = 0; i < a.length; i++) {
      dotProduct += a[i] * b[i];
      normA += a[i] * a[i];
      normB += b[i] * b[i];
    }
    
    return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
  }
  
  // Batch embed multiple texts (more efficient)
  async embedBatch(texts: string[]): Promise<number[][]> {
    await this.initialize();
    if (!this.embedder) throw new Error('Embedder not initialized');
    
    const embeddings: number[][] = [];
    
    // Process in smaller batches to avoid memory issues
    const batchSize = 8;
    for (let i = 0; i < texts.length; i += batchSize) {
      const batch = texts.slice(i, i + batchSize);
      const batchPromises = batch.map(text => this.embed(text));
      const batchEmbeddings = await Promise.all(batchPromises);
      embeddings.push(...batchEmbeddings);
    }
    
    return embeddings;
  }
}